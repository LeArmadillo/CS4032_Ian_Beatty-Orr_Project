require 'json'
require 'socket'

class SearchResult
  words = nil
  url = nil
  frequency = nil
end

InetAddr = Struct.new(:ip, :port)

class PeerSearchInterface
  attr_accessor :name

  def initialize(name_in)
    @name = name_in
    @s = nil
    @localInetAddr = nil
    @id = "NILID"
    @guid = "NILGUID"
    @bootstrap_ip = "NILIP"
    @routing_table = Hash.new #HashWithIndifferentAccess.new
    @gateway_table = {}
    @next_nid = 0
    @m_max = 32     # log2b(L)
    @n_max = 16     # 2b-1
    @b = 4
    @lc = 32
    @lb = 128
    @linkHash = {}
  end

  def init( udp_socket, inetAddr_in )
    @s = udp_socket
    @localInetAddr = inetAddr_in
    #puts "PPPPPPPPPPPPPPPPPPPP", @localInetAddr
    self.listenLoop()
  end

  def PaddGUID( guid_in )
    guid_in = guid_in.to_s(4)
    padd_amount = @lc - guid_in.length
    for i in 0..padd_amount-1
      guid_in = "0" + guid_in
    end
    return guid_in
  end

  def Hash_Func( str )
    hash = 0
    i = 0
    while i < str.length
      i = i + 1
      c = str[i]
      hash = hash * 31 + ?c.ord
    end
    #print "HASH: ", hash.abs
    hash = hash.abs
    return PaddGUID( hash )
  end

  def nextHop( target_id )
    m = 0
    n = -1
    #puts @guid, target_id
    while @guid[m] == target_id[m] && m < @m_max
      #puts m
      m += 1
    end
    n = target_id[m].to_i
    print name, "nextHop"
    #puts @routing_table
    return InetAddr.new( @routing_table[[0,m,n]]["ip_address"], @routing_table[[0,m,n]]["port"] ), m, n
  end

  def getMnN( target_id )
    m = 0
    n = -1
    #puts @guid, target_id
    while @guid[m] == target_id[m] && m < @m_max
      #puts m
      m += 1
    end
    n = target_id[m].to_i
    return m, n
  end

  def diff( node_guid )
    #puts @guid, node_guid
    iGuid = @guid.to_i
    iNodeGuid = node_guid.to_i
    t = iGuid - iNodeGuid
    return t.abs
  end

  def halfDiff( node_id )
    half_id = node_id
    m = 0
    while @guid[m] == node_id[m] && m < @m_max
      m += 1
    end
    m > 30
      return -1
    end
    if node_id[m] > @guid[m]
      half_id[m] = (node_id[m].to_i + 1).to_s
    elsif node_id[m] < @guid[m]
      half_id[m] = (node_id[m].to_i - 1).to_s
    else
      puts "halfDiff Error"
    end
    m += 1
    half_id[m] = "8"
    m +=m 1
    while m < @m_max
      half_id[m] = 0
      m += 1
    end
    t = half_id.to_i - node_id.to_i
    return t.abs
  end

  def strToSym( str )
    sym = str.gsub('[', '')
    sym = sym.gsub(']', '')
    c = sym.split(', ')
    c0 = c[0].to_i
    c1 = c[1].to_i
    c2 = c[2].to_i
    return [c0,c1,c2]
  end

  def useRouteInfo( routeTable )
    for addr in routeTable
      addr = strToSym( addr )
      if @routing_table.has_key?(addr)
        if halfDiff( routeTable[addr]["node_id"] ) < halfDiff( @routing_table[addr]["node_id"] )
          @routing_table[addr] = routeTable[addr]
        end
      else
        @routing_table[addr] = routeTable[addr]
      end
    end
  end

  def removeAddr( node_id )
    for addr in @routing_table.keys
      if @routing_table[addr]["node_id"] == node_id
        @routing_table.delete([addr])
      end
    end
  end

  # Send message to all nodes in routing table of node except messages with the node ID contain in <from>
  # <from> may be nil for a true broadcast
  def sendBroadCast( from, mesg )
    for addr in @routing_table.keys
      if @routing_table[addr]["node_id"] != from
        @s.send mesg, 0, @routing_table[addr]["ip_address"], @routing_table[addr]["port"]
      end
    end
  end

  def joinNetwork( gateInetAddr_in, id_in, target_id )
    @id = id_in
    @gateInetAddr = gateInetAddr_in
    @guid = Hash_Func( @id )
    for m in 0..@guid.length
      n = @guid[m].to_i
      @routing_table[[0,m,n]] = { :node_id => @guid, :ip_address => @localInetAddr.ip, \
       :port => @localInetAddr.port }
    end
    #puts "ROUTING TABLE HERE WE COME", @next_nid, @routing_table
    #puts @routing_table, nil
    if target_id == nil
      puts @id, "First Node in Network!  Waiting for peers ..."
      return @next_nid
    else
      joinMesg = { :type => "JOINING_NETWORK_SIMPLIFIED", :node_id => @guid, :target_id => Hash_Func( target_id ), \
                   :ip_address => @localInetAddr.ip, :port => @localInetAddr.port }.to_json
      #puts @id, joinMesg
      @s.send joinMesg, 0, @gateInetAddr.ip, @gateInetAddr.port
      return @next_nid
    end
    @next_nid += 1
  end

  def leaveNetwork( network_id )
    if routing_table.empty
      puts "You may not leave the network as you are the sole bootstrap node"
    else
      leaveMesg = { :type => "LEAVING_NETWORK", :node_id => @guid }.to_json
      sendBroadCast( nil, leaveMesg )
    end

  end

  def indexPage( url, unique_words )
    #puts unique_words, unique_words.length
    for i in 0..unique_words.length
      wordHash = Hash_Func( unique_words[i] )
      puts unique_words[i]
      indexMesg = { :type => "INDEX", :target_id => wordHash, :sender_id => @guid , :keyword => unique_words[i],
                    :link => url }.to_json
      nh = nextHop( wordHash )
      s.puts indexMesg, 0, nh.ip, nh.port
    end
  end

  def search( unique_words )
    for i in unique_words.length
      wordHash = Hash( unique_words[i] )
      searchMesg = { :type => "SEARCH", :word => words[i], :node_id => wordHash, :sender_id => guid }.to_json
      nh = nextHop( wordHash )
      s.puts indexMesg, 0, nh.ip, nh.port
    end
  end

  def listenLoop()
    x = Thread.new{
      #puts "I am a thread"
      i = 0
      while true
        i = i + 1
        puts @name, "Loop", i
        jsonIN = @s.recv(65536)
        puts @name, jsonIN
        parsed = JSON.parse(jsonIN)
        self.respond( parsed )
      end
    }
  end

  def respond( message )
    if message["type"] == "JOINING_NETWORK_SIMPLIFIED"
      #puts "h1"
      target_guid = message["target_id"]
      joining_guid = message["node_id"]
      #puts "h2"
      tm, tn = getMnN( target_guid )
      #puts "h3"
      jm, jn = getMnN( joining_guid )
      #puts "h4"
      @gateway_table[:node_id] =  { :node_id => message["node_id"], :ip_address => message["ip_address"], \
       :ip_address => message["port"] }
      #puts "h5"
      if !@routing_table.has_key?([0,jm,jn]) || diff( joining_guid ) < diff( @routing_table[[0,jm,jn]]["node_id"] )
        #puts "h6"
        @routing_table[[0,jm,jn]] = { :node_id => message["node_id"], :ip_address => message["ip_address"], \
         :port => message["port"] }
      end
      #puts"h7", tm
      if tm < 32
        puts "C"
        joinMesgRelay = { :type => "JOINING_NETWORK_RELAY_SIMPLIFIED", :node_id => message["node_id"], \
         :target_id => message["target_id"], :gateway_id => @guid }.to_json
        puts "CD"
        puts @routing_table, tm, tn
        @s.send joinMesgRelay, 0, @routing_table[[0,tm,tn]]["ip_address"], @routing_table[[0,tm,tn]]["port"]
        puts "D"
        #puts @routing_table[0][m][n]["ip_address"], @routing_table[0][m][n]["port"]
      elsif tm == 32
        #puts "F"
        #puts @guid, message["node_id"], @localInetAddr.ip, @localInetAddr.port, @routing_table
        routingInfoMesg = { :type => "ROUTING_INFO", :gateway_id => @guid, :node_id => message["node_id"], \
         :ip_address => @localInetAddr.ip, :port => @localInetAddr.port, :route_table => @routing_table }.to_json
        #puts "G"
        @s.send routingInfoMesg, 0, message["ip_address"], message["port"]
        #puts "H"
      else
        puts "M is bigger than 32 ERROR!"
      end
    end


    if message["type"] == "JOINING_NETWORK_RELAY_SIMPLIFIED"
      puts "RELAY"
      target_guid = message["target_id"]
      joining_guid = message["node_id"]
      gateway_guid = message["gateway_id"]
      tm, tn = getMnN( target_guid )
      jm, jn = getMnN( joining_guid )
      nh, gm, gn = nextHop( joining_guid )
      if tm < 32
        joinMesgRelay = { :type => "JOINING_NETWORK_RELAY_SIMPLIFIED", :node_id => message["node_id"], \
         :target_id => message["target_id"], :gateway_id => message["gateway_id"] }.to_json
        @s.send joinMesgRelay, 0, @routing_table[[0,tm,tn]]["ip_address"], @routing_table[[0,tm,tn]]["port"]
      elsif tm == 32
        #puts @guid, message["node_id"], @localInetAddr.ip, @localInetAddr.port, @routing_table
        routingInfoMesg = { :type => "ROUTING_INFO", :gateway_id => message["gateway_id"], :node_id => message["node_id"], \
         :ip_address => @localInetAddr.ip, :port => @localInetAddr.port, :route_table => @routing_table }.to_json
        @s.send routingInfoMesg, 0, nh.ip, nh.port
      else
        puts "M is bigger than 32 ERROR!"
      end
    end

    if message["type"] == "ROUTING_INFO"
      #addAddr( message["sending_id"], message["node_id"], message["node_id"] )
      useRouteInfo( message["route_table"] )
      if message["gateway_id"] == @guid
        if @gateway_table.has_key?( message["node_id"] )
          @s.send message, 0, @gateway_table[message["node_id"]].ip, @gateway_table[message["node_id"]].port
        else
          puts "Routing_Info message receave error not key in gatewayTable!"
        end
      else
        nh, gm, gn = nextHop( message["gateway_id"] )
        @s.send message, 0, nh.ip, nh.port
      end
    end

    if message["type"] == "LEAVING_NETWORK"
      removeAddr( message["node_id"])
    end

    if message["type"] == "INDEX"
      if message["target_id"] == @guid
        for url in message["link"]
          if @linkHash.has_key?(url)
            @linkHash[url] += 1
          else
            @linkHash[url] = 0
          end
        end
      ackIndexMesg = { :type => "ACK_INDEX", :node_id => message["sender_id"], :keyword => message["keyword"] }


      else
        nh, tm, tn = nextHop( message["target_id"] )
        @s.send message, 0, nh.ip, nh.port
      end
    end





  end






=begin
  def diff( node_id )
    close = @guid
    dist = node_id - @guid
    dist = dist.abs
    puts ":", @routing_table
    @routing_table.each_key{ |key|
      puts key, "loo"
      lll = node_id - key
      puts "boo"
      if lll.abs < dist
        puts "doo"
        dist = ( node_id - key ).abs
        close = key
      end
    }
    puts "mango"
    return guid
  end
=end

end

